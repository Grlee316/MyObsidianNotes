![[Pasted image 20230404182215.png]]

concurrency vs parallelism
![[Pasted image 20230404182441.png]]

using pthread library

i don't have to allocate new memory
i don't have to create a new structure
stack frame

even if you don't have threads, when you call a function from another function, we create another stack frame

only stack are getting replaced
slow vs fast context switch
switch the page table
that's what happen when you switch between processes

if there's no separation between thread, pthread is not a solution (since there's no security)
you don't want to keep the webserver busy when someone is trying to connect to the webserver

we are using the fork in this instance to "protect"  your webserver
if you care about security, then don't use pthread, use fork instead
when internet explorer, every tab is a thread
if one tab crashes, all the other tabs is still working
if one tab crashes on IE, the whole IE crashes

what memory segment get copied to the pthread? (HEAP, DATA, TEXT)
and what memory segment got create again? (STACK)
close book, close text

![[Pasted image 20230404183830.png]]
once you compile an application, you save the data, and place it somewhere in the memory of how big the thing is

![[Pasted image 20230404184149.png]]
how can this instruction is being implemented?
there's no SOC that will wait for that long
processor is much faster than the memory

instruction sets that can do it in one go
how is it almost impossible? because its very slow


LUT -> LOOK UP TABLE

![[Pasted image 20230406174043.png]]

![[Pasted image 20230406174148.png]]

you will be providing function as an argument
![[Pasted image 20230406174419.png]]
![[Pasted image 20230406180357.png]]
What is the critical section of this code?
where this code could failed?
++glob;

^ something in the memory that's shared between the two threads

![[Pasted image 20230406180950.png]]

3 new functions

![[Pasted image 20230406181306.png]]
trying to lock, you cannot unlock it since you were not able to lock it 
switch can happen in between, just the second thread cannot unlock the door

atom supposed to be indestructables
or indivisble
works like a flag, on or off, 0 or 1

![[Pasted image 20230406182505.png]]

![[Pasted image 20230411173843.png]]
Locking and unlocking mechanism

Test and Set

![[Pasted image 20230411173927.png]]

if the value is 1 already, then it means someone else already did it before me
why is it not a problem?
because if you lock it already, and you;re the one that does the unlocking, then you're the only one that have access to that

you're not unlocking something that you're not locking

![[Pasted image 20230411174252.png]]

this is not a regular flag, this implemented in the hardware, and happens in one clockcycle
instead of splitting into 3 different istruction , it happens in 1
if what we find inside is a zero, the update, will jump out from the while function (antyhing else but 0, then it will stay in the while loop)

if the value is not 0, will it change?
if you don't get the lock, then it will not change
only the thread that acquire the lock it suppose to be able to unlock it

only one thread can change the flag

![[Pasted image 20230411175241.png]]
when it create multiple thread you don't need to assign a same function

if the resource get released, you suppose to be able to assign it right away

ignoring you, or signaling you

get the lock
waiting until something is being available
while i'm waiting, i'm releasing this lock
if you don't find it then you will release the lock

signing up for the lease
releasing the store

if you got 2 locks
you will ended up with a deadlock
If you're not 0, you will not even wait

![[Pasted image 20230411182823.png]]
number of customer waiting
number of producer waiting
both will be 0
display it every 5 seconds

check against 0
2 conditional variables
operator that calls people in the list

![[Pasted image 20230411183452.png]]
if versus while

semaphore vs mutexes
mutex -> when you lock one resource
semaphore -> 5 resources (multiple resources but limited)
locked when one of them is being used

# Lecture 13 - 04132023

Avoid changing that variable
wait until the lock is acquired
(mutex)

Mutex is a special
Execute in one line (flag with a special property), can get set and clear in one instruction

What is one instruction?
![[Pasted image 20230413174733.png]]

protected an area by using locking, unlocking mechanism


![[Pasted image 20230413175226.png]]
possible problem at:
![[Pasted image 20230413175250.png]]

Function cannot know the size of the array
you need to provide the function with array and size

Pointer to a structure
Everything is a structure

signaling all of the customer in this list

if the supplier says no, you're going back to the list
locks, pauses there

leaving unlock your mutex
return from that function, you're locking it again (from inside this funtion)
![[Pasted image 20230413180703.png]]
in and out (the code is locked by this function)
"unlock the door to let the other people signal you"

what if there're more people waiting in that list
send signal to everyone, but not everyone is able to get it
"don't forget to unlock it when you leave"
order is not matter
operating system will decide, the order of the list does not matter
the os does not have visibility of what's the code is doing

2 threads
![[Pasted image 20230413181242.png]]


main function will have some kind of loops

sleep for 1 second 

somehow need to figure it out, every how many second, need to find producer (5 second ), and produces 2-5

1 second every customer


create thread function should have some loops

don't need to have a loop in producer or customer function
producer will work only if there's room in the stock (if the stock is less than 10)
producer should lock if the stock is more than 10

always be low stock, more customer (1 * 1.5) in 10 seconds, you will have 10-20 request
2 producers 2-5 ( between 4-10 will be produced), while between 10-20 is being requested
will never be 0 ever


-> missing codition completely
-> the other guy still need to check if they get notified or not, only the first one in line will get the video card
-> Pay attention to line 123
![[Pasted image 20230418181247.png]]
-> the other memory segment, stack have a new stack (stack get created every thread)
the other does not get created, so it could get accessed from the other thread
-> unlock first, then send the conditional signal
-> if not, the customer will get the lock 

# LECTURE 14 - 04202023

![[Pasted image 20230420180359.png]]

modified by multiple thread (if its a critical section)
producer is incrementing the producer
consumer incrementing the consumer, and does not increment producer

![[Pasted image 20230420183602.png]]

- Nothing in stock
- going to waitlist
- while statement or if statement will work just fine
- when you do -- for value 0, you will get 0xFFFFF (max value from that variable)
- it will look like best buy is overflowed
- what we would like to have is we got notified, we cannot have two people inside the best buy at the same time but all of the will be inside the best buy
- whenever you are in bestbuy, you wil check if its empty
- 