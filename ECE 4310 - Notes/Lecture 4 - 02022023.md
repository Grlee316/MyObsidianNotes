Original computer performs one task
- input
- run
- output

- an operator will wait for the task to complete and load the next task (operate the system)
- operating system will replace the manual operator
	- improvements made to
		- run multiple processes (can do multiple things at the same time)
		- better use all the resources
		- save programs and data between runs
- Virtualization
	- make each process belive it has all the resources

instruction sets

![[Pasted image 20230202175344.png]]

code -> all the codes (can also called text)
static data -> is for the global variables
heap -> memory allocation (by user)

Processes (structure that have a bunch of things inside)
![[Pasted image 20230202175234.png]]

when we do data structure, we're focusing more on the stack and heap, now we're focusing more on the code

There're a bunch more segment, but we need to learn/understand this part
4 (code, data, heap, stack)

small rectangle inside of the SOC is called register
using specific instruction from the instruction sets to move data from the register

![[Pasted image 20230202180509.png]]

the CPU will execute the instruction in orders once it reseted 

GPR -> General Purpose Register
![[Pasted image 20230202180843.png]]

Program counter / instruction pointer <- keep the address of the current instruction
maybe now we have a lot more than 1 since we have multiple processors
PC/IP -> will scan through

![[Pasted image 20230202181330.png]]

stack is managed by the CPU
heap is managed by yourself

stack pointer 

instruction pointer goes from top to the bottom
stack pointer goes from the bottom to up
the memory is a part of the real memory that the operating system allocated for that program

stack pointer will point to "where the stack starts"
"memory space for the process, could be anywhere in the physical memory"
the operating systems will keep track of the proceses using structure

when you switch processes, you assign them to a structure

======================================================
Maybe inside the node, keep the time, and some other stuffs (like the registers) -> a section to hold the "context of that register". 
![[Pasted image 20230202182449.png]]

List of processes that ready to run
what operating systems like to do for some processes that not well behaved is to move it to different list, let's say from ready to run to waiting (idle)

![[Pasted image 20230202182610.png]]

Running can only have 1 process
![[Pasted image 20230202182740.png]]

the running processes (register) is the one that's in the CPU "right now"
if you want to switch, then you take it off from the running list, copy the state inside that structure, and move it to your ready to run lists. 

- remove a node from the list and replace the node
- Pa next -> pc (so it will jump over the PF)

ready to run means it's the next processes that will be ready to run in the CPU

register contex -> all the register in the CPU
open files, input output
in linux, everything is a file

in C
fseek -> to move a current pointer inside the pointer to the one that you want
(how do you move inside the hard drive)
fread -> to read the file

dd -> disk duplicate opening the file 
you need to know what file is being open for a specific processes

![[Pasted image 20230202183547.png]]
# ps aux -> 
list all the processes and will tell you as well the current state (use it in the terminal)

there's also a zombie state

API -> application Program Interface

fork is splitting / making copy of your current process
exec is loading a new program (destroy your current process, and load the new process)

first a fork get executed then you execute the new program
then the copy of your process getting replaced 
process id is also something that present inside that structure node
(OS will go through the list to find the "proper ID that they want to destroy")

wait is to move the process to the idle queue/blocked state

kill -9. process id
