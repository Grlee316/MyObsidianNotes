

Do something in C code, with linked list

linux have a table with uniformly distributed number
each time you have to access random number, the system will go to the first element, if you re run this again, you will see the same thing again

the workaround is to use seed
it will move the readpointer inside the table
usually you will generate that seed
multilevel feedback queue

in you c sample, you can hardcode how many queue you have
at least 3, but not 5
allotment is the amount time, we can use define to hardcode this part

how long the process will spend time at the queue with priority

how many number of jobs: because it will be a linked list, we should be able to ask the user how many jobs the user want, job 1, parameters, all the new job will be added to the highest priority queue. 
![[Pasted image 20230223175133.png]]

if you're doing IO, the CPU will move you from the ready queue, to the wait queue, but we will not use wait queue here, so we will use the ready queue only

we will use boost
after a specific amount of time, the process need to move back to the highest priority queue

50 + 20 + 10 -> 80 unit of time, then you will go back to the priority queue
you need to know how long the process executed

length of the job, we need to have a way to end this processes. based on how many jobs i want to have

when a process start, even if I give you 4 process at the beginning, it does not start at the same time

in my case, I use a joblist, and the way it works, have 3 integer per process, in between we have a comma

![[Pasted image 20230223175913.png]]
first process start at time 0,
second start at time 100, 30 time unit long

-c is to make it run

add process name -> can be one character (a, b, c,e etc)

also have time unit
job 1 start after 100 units
we don;t have to do this one by one, we can do jump
how much time we still have

![[Pasted image 20230223180735.png]]

![[Pasted image 20230223180753.png]]


![[Pasted image 20230223180828.png]]

Job zero never bumps back to priority 2 queue 

# lottery ticket:
pick random ticket from each process
you only need to save the number of ticket
the total number of ticket

![[Pasted image 20230223182651.png]]

the ticket number can be anything, as long as its not 0
they don't care about the size, its all about the ticket number

total ticket number: 950
assuming a, have the first 100 tickets
b have the 101 -> 701 ticket
c have the rest etc
you will need to pick a ticket from 950 tickets
you will start counting from the number from the left to the right+-1

ticket 300 owned by process b
it means b runs
move from ready state to the run state


![[Pasted image 20230223183116.png]]
After the first iteration, it become like above

![[Pasted image 20230223183323.png]]

next iteration, we got the second picture, we will keep doing this

```c
while(800 < sum){
	p = p->next;
	sum+=p-tickets;
}
```

![[Pasted image 20230223183711.png]]

if the process is finish, then remove the list


"create your own currency to convert 2 tickets to 2000 subtickets"
it make sense to give your ticket to other process to increase the number of tickets and chances

Balance -> Left and Right side is about the same
Change the root node each time (to make it balance and such)
but we don't really need to have it
red black tree


if all of them is equal, we don't change the nice number for all of them
![[Pasted image 20230228181207.png]]

if you're a nice process, you will get "smaller process"
The "nicer you are", the Less time you get


you're looking at the process with the "smalles of the Vruntime"
I ended up with the smallest value, but everything is fair again
after we mess up with the time slice, we check the vruntime

![[Pasted image 20230228181738.png]]

The Vruntime is the real run time
5ms = scheduler_latency

1 -> Na = Nb = Nc = 0
weight for a = weight for b = weight for c = 1024
runtimeA = runtimeB = runtimeC = 1/3 x 5ms

vruntime a = vruntime b = vruntime c = 0 + 1024/1024 x 5/3

2-> Na = 10, Nb = 0,Nc = -20
weight for A = 110, weight for B = 1024, weight for C = 88k
runA = 110/90k x 5 ms = 0.006 ms = 6us...
runB = 1024/90k x 5 ms = 60us....
runC = 88k/90k x 5ms = 4.934ms....

for linux, we're the one that give or be nice to the processes

they do not happen at the same time
they happen every time a new processes come

minimum granularity to ensure there's no revolution
![[Pasted image 20230228184318.png]]
so you dont want to make it less than the minimum granularity
^ talks about the "runtime"

min_granularity = 2us
^ you will get at least that much

