Scheduling

Queue processes that's:
ready to run
waiting list
running

we're looking at the queue of the processes that's ready to run, so we can choose which process we will run

you tell me what you want to run first
what other engineers they thought they can use for embedded system

![[Pasted image 20230221173816.png]]
**FIFO** -> Run until it finished
after the first process is finish, we're going to the next process
if this works, we should use this
why would we use MLFQ if we can use FIFO

**Shorter Job First** -> fake schedule
you cannot know which one will run the fastest or the slowest, 
the only reason of why this is here is because they want to mention about the metric so we can "COMPARE"

i.e. A = 10u, B = 30 u, C = 2u
we need to show the metric that c is better
they're already in the fifo list,
Tfifo = ( 10+40+42 ): 3 -> 30.66
Tsjf = (2+12+42):3 -> 18.66

Tresponse fifo = (0 + 10 + 40) : 3 = 50/3
Tresponse sjf = (0 + 2+ 12) : 3 = 14/3


**Round Robin** -> Time slice, Timer IRQ every x ms
if you can trigger interrupt, (sometimes they will tell you that)
your microprocessor / SOC will have a pin that can trigger interrupt

the way operating system works :  bootloader (this will load the operating system)
during the load process of the operating system, there's something that will tell what's plugged into the system
it will create a file called device tree file

Table of interrupt
you'll use them later on

lookup table in between the interrupt table, and the specific table in the memory when you have those interrupt

loaded at boot time, high previlleges for that

The CPU gets notified, the CPU will stop the current process if it happens, and will execute the current interrupts, and after that will give the control to the operating system

in Round Robin, you will not wait till the process is finished
you need to decide how big is the time unit
once you have your time sliced, you go back to the end of your queue
lets define u = 3 (time unit)
(1) A runs 

![[Pasted image 20230221180237.png]]
you take it from ready queue to the running queue

lets say that A finish (the allocated time slice) -> the time slice is finish, then:
the process itself is not finished, it just finished the current time slice
![[Pasted image 20230221180433.png]]
B runs (#2)
![[Pasted image 20230221180526.png]]

![[Pasted image 20230221180731.png]]

We have a first job that's actually finish, C have 2 units, and it actually finished before the 3 unit expired ( c runs 2u ), the operating system goes back in charge

![[Pasted image 20230221180919.png]]

If you cannot do MLFQ or the lottery, then just do the round robin

what do we call the first node in the list?
HEAD

a function to add it to the end
it would make sense in your list structure to have the pointer to the last element

SEMINAR:
- LIST
- NODE -> EACH NODE IS THE PROCESS
- Move one element in the list
  How to add the element back to the list, but when you add you add it back to the end
  head and tail of the list, and figure out how to add 
2 members are mandatory
PID (not mandatory but nice to have)
The size (how much is left)
Pointer to the next element in the list
you don't have to keep track of what's finish, if its finish, then it can disappear

take it from the head, substract, print

**MLFQ** 
- you want to manage so that the scheduller works better
- will consider the frst queue the highest priority queue
- has more than one queue (ready queue)
- we need to finish the ready queue first, and after that we will do the idle one
- RR -> is round robin
- round robin on  many different priorities
- only one process can run at a time
only the first and the second one is empty
probb all of the processes will be implemented at a same time
all new process goes to the queue 1

if your process yield back to the operating system (it gives up)
according to this rule, you keep it back to the same queue it came from
you force it down to the different queue once it does the 15 unit
