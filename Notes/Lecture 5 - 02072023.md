Argument are provided by the operating systems

application itself is apt

ll-> Alias to ls -all

![[Pasted image 20230207180431.png]]

```text
./a.out
this is just to call the "output as a.out"
```

argc is the count
argv is the vetor of strings

to use fork, we need to include <unistd.h>
fork(); does not have argument

fork get executed, a new stack frame is created
somewhere inside this fork function, we create a duplicate

![[Pasted image 20230207181805.png]]

until the line 10, its already happen (in the original process)
you create a stack frame of fork, from it down, you have "2" processes
it does not ran simultaniously

the original process will still have the assignment, and the return value from the fork will be assigned to PID

![[Pasted image 20230207182213.png]]

only the parents have the assignment

it get executed sequentially, but we don't know when it will get executed

there's a way to control who get executed first

from line 11 down

the parent will know the name of the child, but the child does not know, its "too new"

right side executed first, and it print out that first
return the id of the child process in the main process


in the child process, the fork return 0, but in the parent process it will return the ID of the child

![[Pasted image 20230207183410.png]]

pid_t fork(void); is the function prototype

new memory spaces is created from the content
"no one tells the child what the name is"

include <errno.h> to tell us what the error number means
from that line, it completely independent

![[Pasted image 20230207184025.png]]

![[Pasted image 20230207184048.png]]

will the child see the else? no because it will never see that
will the parents see the else? yes because the pid == 0 will be "skipped"

when do you want to use the fork?
when you have server, parents does not want to get busy when someone is trying to connect to the server

child is the one that process it
chrome is using the same thing when you create the new tab

if you write the command inside the shell, the way it will work, the shell creating a fork (a copy of itself, and replacing itself with whatever you issue)

exec function from that terminal

exec function
wait function
forks
PID -> Process Identifier


how to create your own shell
use exec

which ls only works because it can check the specific bin
![[Pasted image 20230209175954.png]]

when we're trying to find which ls, we're defining the full path

![[Pasted image 20230209180256.png]]

NULL as the end (to let it know that we don;t have any other arguments)

![[Pasted image 20230209180359.png]]

need to be casted as char *

shell that we need to implement, it should execute a loop, and read an instruction on the terminal, in someway, to read the input from the user, and hope the user have "valid command"

this exec family will completely replace the current program

in our case, the break; is not even get executed, (the parents still there, but the child does not get executed)

we want the parents to wait for the child to finish

if we don't use the pointer, it will get destroyed in the stack frame
![[Pasted image 20230209181459.png]]

& will return the address of that variable
in OS, treat all warning as error


windows embedded on a camera
busy box -> form of linux, streamed down, control 

add the while statement, and wait to read the input from the user
add your own command too
backdoor, lets say quit, then get out from that loop
shell is the terminal
shell called bash

Define is not seen by the compiler
it will be seen only by the precompiler, and it will do a search and replace'

![[Pasted image 20230214175957.png]]

file stream that open by default
process id
by the open file

3, one for input, one for output, one for errors
![[Pasted image 20230214180537.png]]

Capture signal
kill or ctrl c

add & at the end, and it 

![[Pasted image 20230214181809.png]]
need to be ended with null
this part will read the enter press button

![[Pasted image 20230214183244.png]]
if you don't have a backslash zero, it will read the whole memory

i++ will take twice as much time compared to ++ since it will make a copy of i first

a = i++ -> this will make sense since you will store the value of i++ to it

what does os use to keep track of the process
data type -> struct

![[Pasted image 20230216183504.png]]

if you don't have line 33, the line 40 does not get affected since you just exit the child process and that wait is inside the parents process, so it just exit the child process and still run the parents process



status is the "feedback from the child"
exit 71
