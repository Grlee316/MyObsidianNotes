jump, branch, etc

MIPS
- Microprocessors
- without interlocked (request, acknowledge)
- stages
- pipeline
- 

RISC -> RISC 5
	- MIPS
	- ARM -> cortex, etc
	- NIOS -> part of altera, and now intel
	- Mircroblaze
	- Picoblaze -> xilinx

fine grain architechture -> FPGA
coarse grain architecture -> vague, huge, 

processing element -> "core"
a set of process from the arithmetic and logic perspective 

activation function, node firing

this are using pipelining and interlock

The last three is a softcore processor

CGRA -> 
team in finland creating the c compiler that able to use this
higher than the "lower"
if the lower is a lookup table, then the higher one is "possible"

RISC V is an open source
Cortex -> ARM -> using RISC

PIC18F -> 2 stages pipeline
PC counter

everything using RISC is harvard

Data format:
signed, unsigned

any wire can handle, 0, 1, x, or z

euler expansion form
1 + x/2! - x^2/3! +....

you can expand it to an expanded instructions
computer arithmatic

data path

control path

Instruction formatting
- R Type
- I type
- J type


R is anything that's happening in the GPR -> signed/unsigned
I is arithmetic (add, subtract, multiplication, div)

Add
	- signed
	- unsigned
	- immediate -> constant + whaever in the register, and store it again in register

the first two is R type
and the last one is I type


opcode -> 6 bits
DR -> Destination register
source 1
source 2
shamt
the last one will be "function"

(logical process)-> and, shift left, shift right, every other logical process

log 2 # of bits (5 bit) 
you can consider this as r type

000000
as r type, will talk to the ALU
function will tell what you're trying to do and shamt is the amount of bits 

32 GPR
i.e. add $3,$1,$2,.....

everything will be a 64 bits

J type -> "jumper"
branch equal
branch if not equal

its a combination between i and r type
(r type followed by jump)
