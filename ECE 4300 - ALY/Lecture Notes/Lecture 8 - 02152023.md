Risc Architechture -> Simple addressing mode, so only load and store

-64 bit architechture
-Risc Architechture
-1024 Inst
-GPR
-2byte addresable

Every single register is 64

Memory size (mem size) = 2 ^ 64 * 2 ^ 4 (16)
2^64 location to fill

64 bit architechture, so everything need to be 64 bit
log 2 of 64 -> 8 bits

big endian-> critical path and the executing time will be less
HDL -> Hardware Descriptive Language
(describing the circuit how it will looks like)
the wire routing

if it take 80-82% , the FPGA start to panicking
floorplan -> 

big endian -> little endian 
doing swapping in their case
![[Pasted image 20230215122630.png]]

Big Endian -> performace system like big service

little endian-> little stuffs, like your machine
swapping is for them to get a better routing for their own architechture will give them better strategy, less energy, less silicon to be used for the layout

verification -> testing at the chip

12 - 34
to:
34 - 12

byte swapping
bus -> group of wires 

word-> size of the resistor
64 bit -> half of it is 32 bits
byte -> 8 bits

ASCII -> 7 bits
number 8 is parity (pg 68, paragraph 4)
detecting errors
and there's another one to correcting errors
(odd or even) -> parity one or zero
if its wrong, then it will ask to re send it again
electric wave, and magnetic wave and they're orthogonal

error correcting code

R type -> the process involving arithmatic (GPR)

40% wave that come out from mouth is information
60% is nothing

or $3, $4, $5
Those are usign R type

if I want to use I, it will be
ori(or immediate) $3, $2, const

const -> will get expanded to the 32
constant -> 16 bits, the last value will be replicated 16 times so the value will be 32 bits
if its unsigned you will fill it with zero, if its signed then you just use the MSB


best strategy to find the way to consume less energy and such

shift logical
![[Pasted image 20230215135801.png]]

![[Pasted image 20230215140006.png]]

every single neurons have 10^14 synaptics

![[Pasted image 20230215140614.png]]
slt $6,$2,$3, it will be + (2 is negative (signed))

$0 is the ground data,
branch and link save the return address PC+4 into $31

t timber
v variable, etc
constraint in stack


